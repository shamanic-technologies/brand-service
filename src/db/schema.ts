import { pgTable, serial, varchar, timestamp, index, unique, uuid, text, uniqueIndex, foreignKey, check, date, jsonb, integer, boolean, bigint, numeric, json, primaryKey, pgView, pgEnum } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const belongingConfidenceLevelEnum = pgEnum("belonging_confidence_level_enum", ['found_online', 'guessed', 'user_inputed'])
export const organizationIndividualStatus = pgEnum("organization_individual_status", ['active', 'ended', 'hidden'])
export const organizationIndividualThesisStatus = pgEnum("organization_individual_thesis_status", ['pending', 'validated', 'denied', 'generating'])
export const organizationRelationStatus = pgEnum("organization_relation_status", ['active', 'ended', 'hidden', 'not_related'])
export const organizationRelationType = pgEnum("organization_relation_type", ['subsidiary', 'holding', 'product', 'main_company', 'client', 'supplier', 'shareholder', 'other'])
export const webPageCategoryEnum = pgEnum("web_page_category_enum", ['company_info', 'offerings', 'credibility', 'content', 'legal', 'other'])


export const pgmigrations = pgTable("pgmigrations", {
	id: serial().primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	runOn: timestamp("run_on", { mode: 'string' }).notNull(),
});

export const users = pgTable("users", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	clerkUserId: text("clerk_user_id").notNull(),
	orgId: uuid("org_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index().using("btree", table.clerkUserId.asc().nullsLast().op("text_ops")),
	unique("users_clerk_user_id_key").on(table.clerkUserId),
	index("idx_users_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
		columns: [table.orgId],
		foreignColumns: [orgs.id],
		name: "users_org_id_fkey"
	}).onDelete("cascade"),
]);

export const brands = pgTable("brands", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text(),
	url: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	externalOrganizationId: text("external_organization_id"),
	organizationLinkedinUrl: text("organization_linkedin_url"),
	domain: text(),
	status: text(),
	generatingStartedAt: timestamp("generating_started_at", { withTimezone: true, mode: 'string' }),
	location: text(),
	bio: text(),
	elevatorPitch: text("elevator_pitch"),
	mission: text(),
	story: text(),
	offerings: text(),
	problemSolution: text("problem_solution"),
	goals: text(),
	categories: text(),
	foundedDate: date("founded_date"),
	contactName: text("contact_name"),
	contactEmail: text("contact_email"),
	contactPhone: text("contact_phone"),
	socialMedia: jsonb("social_media"),
	logoUrl: text("logo_url"),
	orgId: uuid("org_id").notNull(),
}, (table) => [
	uniqueIndex("idx_brands_org_domain").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.domain.asc().nullsLast().op("text_ops")),
	index("idx_brands_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_organizations_categories").using("btree", table.categories.asc().nullsLast().op("text_ops")).where(sql`(categories IS NOT NULL)`),
	uniqueIndex("organizations_domain_unique_index").using("btree", table.domain.asc().nullsLast().op("text_ops")).where(sql`(domain IS NOT NULL)`),
	index("organizations_logo_url_index").using("btree", table.logoUrl.asc().nullsLast().op("text_ops")).where(sql`(logo_url IS NOT NULL)`),
	index("organizations_status_index").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status IS NOT NULL)`),
	uniqueIndex("organizations_url_unique").using("btree", table.url.asc().nullsLast().op("text_ops")).where(sql`(url IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [orgs.id],
			name: "brands_org_id_fkey"
		}).onDelete("cascade"),
	unique("organizations_external_organization_id_key").on(table.externalOrganizationId),
	check("organizations_status_check", sql`(status IS NULL) OR (status = 'generating'::text)`),
]);

export const individualsPdlEnrichment = pgTable("individuals_pdl_enrichment", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	individualId: uuid("individual_id").notNull(),
	organizationUrl: text("organization_url"),
	rawData: jsonb("raw_data").notNull(),
	pdlId: text("pdl_id"),
	fullName: text("full_name"),
	firstName: text("first_name"),
	middleName: text("middle_name"),
	lastName: text("last_name"),
	sex: text(),
	birthYear: integer("birth_year"),
	linkedinUrl: text("linkedin_url"),
	linkedinUsername: text("linkedin_username"),
	linkedinId: text("linkedin_id"),
	facebookUrl: text("facebook_url"),
	twitterUrl: text("twitter_url"),
	githubUrl: text("github_url"),
	jobTitle: text("job_title"),
	jobTitleRole: text("job_title_role"),
	jobTitleSubRole: text("job_title_sub_role"),
	jobTitleClass: text("job_title_class"),
	jobTitleLevels: text("job_title_levels").array(),
	jobCompanyName: text("job_company_name"),
	jobCompanyWebsite: text("job_company_website"),
	jobCompanySize: text("job_company_size"),
	jobCompanyIndustry: text("job_company_industry"),
	jobCompanyLinkedinUrl: text("job_company_linkedin_url"),
	jobStartDate: text("job_start_date"),
	jobLastVerified: date("job_last_verified"),
	locationName: text("location_name"),
	locationLocality: text("location_locality"),
	locationRegion: text("location_region"),
	locationCountry: text("location_country"),
	locationContinent: text("location_continent"),
	locationGeo: text("location_geo"),
	workEmailAvailable: boolean("work_email_available"),
	personalEmailsAvailable: boolean("personal_emails_available"),
	mobilePhoneAvailable: boolean("mobile_phone_available"),
	skills: text().array(),
	experience: jsonb(),
	education: jsonb(),
	datasetVersion: text("dataset_version"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	interests: text().array(),
	likelihood: integer(),
	countries: text().array(),
	jobCompanyFounded: integer("job_company_founded"),
	jobCompanyLocationCountry: text("job_company_location_country"),
	jobLastChanged: date("job_last_changed"),
	recommendedPersonalEmail: text("recommended_personal_email"),
}, (table) => [
	index().using("gin", table.education.asc().nullsLast().op("jsonb_ops")),
	index().using("gin", table.experience.asc().nullsLast().op("jsonb_ops")),
	index().using("btree", table.individualId.asc().nullsLast().op("uuid_ops")),
	index().using("gin", table.interests.asc().nullsLast().op("array_ops")),
	index().using("btree", table.jobCompanyLocationCountry.asc().nullsLast().op("text_ops")),
	index().using("btree", table.jobCompanyName.asc().nullsLast().op("text_ops")),
	index().using("btree", table.likelihood.asc().nullsLast().op("int4_ops")),
	index().using("btree", table.linkedinUrl.asc().nullsLast().op("text_ops")),
	index().using("btree", table.organizationUrl.asc().nullsLast().op("text_ops")),
	index().using("btree", table.pdlId.asc().nullsLast().op("text_ops")),
	index().using("gin", table.rawData.asc().nullsLast().op("jsonb_ops")),
	foreignKey({
			columns: [table.individualId],
			foreignColumns: [individuals.id],
			name: "individuals_pdl_enrichment_individual_id_fkey"
		}).onDelete("cascade"),
	unique("individuals_pdl_enrichment_individual_id_unique").on(table.individualId),
	unique("individuals_pdl_enrichment_pdl_id_key").on(table.pdlId),
]);

export const mediaAssets = pgTable("media_assets", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	assetType: text("asset_type").notNull(),
	assetUrl: text("asset_url").notNull(),
	supabaseStorageId: uuid("supabase_storage_id"),
	optimizedUrl: text("optimized_url"),
	caption: text(),
	altText: text("alt_text"),
	isShareable: boolean("is_shareable").default(true).notNull(),
	metadata: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	brandId: uuid("brand_id"),
}, (table) => [
	index().using("btree", table.assetType.asc().nullsLast().op("text_ops")),
	index("media_assets_organization_id_index").using("btree", table.brandId.asc().nullsLast().op("uuid_ops")),
	index("media_assets_organization_id_is_shareable_index").using("btree", table.brandId.asc().nullsLast().op("bool_ops"), table.isShareable.asc().nullsLast().op("uuid_ops")),
	index().using("btree", table.supabaseStorageId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.supabaseStorageId],
			foreignColumns: [supabaseStorage.id],
			name: "media_assets_supabase_storage_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "media_assets_organization_id_fkey"
		}).onDelete("cascade"),
	unique("media_assets_asset_url_unique").on(table.assetUrl),
	check("media_assets_asset_type_check", sql`asset_type = ANY (ARRAY['uploaded_file'::text, 'youtube'::text, 'spotify'::text, 'vimeo'::text, 'soundcloud'::text, 'other'::text])`),
]);

export const supabaseStorage = pgTable("supabase_storage", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	supabaseUrl: text("supabase_url").notNull(),
	storageBucket: text("storage_bucket").notNull(),
	storagePath: text("storage_path").notNull(),
	fileName: text("file_name").notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	fileSize: bigint("file_size", { mode: "number" }),
	mimeType: text("mime_type"),
	fileExtension: text("file_extension"),
	width: integer(),
	height: integer(),
	duration: numeric(),
	metadata: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	md5Hash: text("md5_hash"),
}, (table) => [
	index().using("btree", table.md5Hash.asc().nullsLast().op("text_ops")),
	index().using("btree", table.storageBucket.asc().nullsLast().op("text_ops"), table.storagePath.asc().nullsLast().op("text_ops")),
	unique("supabase_storage_supabase_url_key").on(table.supabaseUrl),
]);

export const individuals = pgTable("individuals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	firstName: text("first_name").notNull(),
	lastName: text("last_name"),
	linkedinUrl: text("linkedin_url"),
	personalWebsiteUrl: text("personal_website_url"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
}, (table) => [
	index().using("btree", table.linkedinUrl.asc().nullsLast().op("text_ops")),
	unique("individuals_linkedin_url_key").on(table.linkedinUrl),
]);

export const brandLinkedinPosts = pgTable("brand_linkedin_posts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	brandId: uuid("brand_id").notNull(),
	rawData: jsonb("raw_data").notNull(),
	postType: text("post_type").notNull(),
	linkedinPostId: text("linkedin_post_id").notNull(),
	linkedinUrl: text("linkedin_url").notNull(),
	content: text(),
	contentAttributes: jsonb("content_attributes"),
	author: jsonb(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	authorUniversalName: text("author_universal_name"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	postedAtData: jsonb("posted_at_data"),
	postImages: jsonb("post_images"),
	hasImages: boolean("has_images").default(false),
	repostId: text("repost_id"),
	repostData: jsonb("repost_data"),
	isRepost: boolean("is_repost").default(false),
	socialContent: jsonb("social_content"),
	engagement: jsonb(),
	likesCount: integer("likes_count").default(0),
	commentsCount: integer("comments_count").default(0),
	sharesCount: integer("shares_count").default(0),
	impressionsCount: integer("impressions_count").default(0),
	reactions: jsonb(),
	comments: jsonb(),
	header: jsonb(),
	article: jsonb(),
	articleLink: text("article_link"),
	articleTitle: text("article_title"),
	hasArticle: boolean("has_article").default(false),
	input: jsonb(),
	query: jsonb(),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	articleImageUrl: text("article_image_url"),
	articleDescription: text("article_description"),
}, (table) => [
	index("organizations_linkedin_posts_author_linkedin_url_index").using("btree", table.authorLinkedinUrl.asc().nullsLast().op("text_ops")),
	index("organizations_linkedin_posts_author_universal_name_index").using("btree", table.authorUniversalName.asc().nullsLast().op("text_ops")),
	index("organizations_linkedin_posts_content_attributes_index").using("gin", table.contentAttributes.asc().nullsLast().op("jsonb_ops")),
	index("organizations_linkedin_posts_content_search_idx").using("gin", sql`to_tsvector('english'::regconfig, COALESCE(content, ''::text))`),
	index("organizations_linkedin_posts_engagement_index").using("gin", table.engagement.asc().nullsLast().op("jsonb_ops")),
	index("organizations_linkedin_posts_has_article_index").using("btree", table.hasArticle.asc().nullsLast().op("bool_ops")),
	index("organizations_linkedin_posts_is_repost_index").using("btree", table.isRepost.asc().nullsLast().op("bool_ops")),
	index("organizations_linkedin_posts_linkedin_post_id_index").using("btree", table.linkedinPostId.asc().nullsLast().op("text_ops")),
	index("organizations_linkedin_posts_organization_id_index").using("btree", table.brandId.asc().nullsLast().op("uuid_ops")),
	index("organizations_linkedin_posts_post_type_index").using("btree", table.postType.asc().nullsLast().op("text_ops")),
	index("organizations_linkedin_posts_posted_at_index").using("btree", table.postedAt.asc().nullsLast().op("timestamptz_ops")),
	index("organizations_linkedin_posts_raw_data_index").using("gin", table.rawData.asc().nullsLast().op("jsonb_ops")),
	index("organizations_linkedin_posts_reactions_index").using("gin", table.reactions.asc().nullsLast().op("jsonb_ops")),
	index("organizations_linkedin_posts_repost_id_index").using("btree", table.repostId.asc().nullsLast().op("text_ops")),
	index("organizations_linkedin_posts_scraped_at_index").using("btree", table.scrapedAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "organizations_linkedin_posts_organization_id_fkey"
		}).onDelete("cascade"),
	unique("organizations_linkedin_posts_linkedin_post_id_key").on(table.linkedinPostId),
]);

export const brandSalesProfiles = pgTable("brand_sales_profiles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	brandId: uuid("brand_id").notNull(),
	valueProposition: text("value_proposition"),
	customerPainPoints: jsonb("customer_pain_points"),
	callToAction: text("call_to_action"),
	socialProof: jsonb("social_proof"),
	companyOverview: text("company_overview"),
	additionalContext: text("additional_context"),
	competitors: jsonb(),
	productDifferentiators: jsonb("product_differentiators"),
	targetAudience: text("target_audience"),
	keyFeatures: jsonb("key_features"),
	leadership: jsonb("leadership"),
	funding: jsonb("funding"),
	awardsAndRecognition: jsonb("awards_and_recognition"),
	revenueMilestones: jsonb("revenue_milestones"),
	urgency: jsonb("urgency"),
	scarcity: jsonb("scarcity"),
	riskReversal: jsonb("risk_reversal"),
	priceAnchoring: jsonb("price_anchoring"),
	valueStacking: jsonb("value_stacking"),
	extractionModel: text("extraction_model"),
	extractionInputTokens: integer("extraction_input_tokens"),
	extractionOutputTokens: integer("extraction_output_tokens"),
	extractionCostUsd: numeric("extraction_cost_usd"),
	sourceScrapeIds: jsonb("source_scrape_ids"),
	extractedAt: timestamp("extracted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_sales_profiles_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "organization_sales_profiles_organization_id_fkey"
		}).onDelete("cascade"),
	unique("organization_sales_profiles_organization_id_key").on(table.brandId),
]);

export const scrapedUrlFirecrawl = pgTable("scraped_url_firecrawl", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	success: boolean(),
	returnCode: integer("return_code"),
	sourceUrl: text("source_url"),
	url: text().notNull(),
	scrapeId: text("scrape_id"),
	content: text(),
	markdown: text(),
	html: text(),
	rawHtml: text("raw_html"),
	links: text().array(),
	title: text(),
	description: text(),
	language: text(),
	languageCode: text("language_code"),
	countryCode: text("country_code"),
	favicon: text(),
	robots: text(),
	viewport: text(),
	template: text(),
	contentType: text("content_type"),
	ogTitle: text("og_title"),
	ogTitleAlt: text("og_title_alt"),
	ogDescription: text("og_description"),
	ogDescriptionAlt: text("og_description_alt"),
	ogType: text("og_type"),
	ogImage: text("og_image"),
	ogImageAlt: text("og_image_alt"),
	ogUrl: text("og_url"),
	ogUrlAlt: text("og_url_alt"),
	ogLocale: text("og_locale"),
	ogLocaleAlt: text("og_locale_alt"),
	searchTitle: text("search_title"),
	ibmComSearchAppid: text("ibm_com_search_appid"),
	ibmComSearchScopes: text("ibm_com_search_scopes"),
	ibmSearchFacetFieldHierarchy01: text("ibm_search_facet_field_hierarchy_01"),
	ibmSearchFacetFieldHierarchy03: text("ibm_search_facet_field_hierarchy_03"),
	ibmSearchFacetFieldKeyword01: text("ibm_search_facet_field_keyword_01"),
	ibmSearchFacetFieldText01: text("ibm_search_facet_field_text_01"),
	focusArea: text("focus_area"),
	siteSection: text("site_section"),
	dctermsDate: text("dcterms_date"),
	proxyUsed: text("proxy_used"),
	cacheState: text("cache_state"),
	cachedAt: timestamp("cached_at", { withTimezone: true, mode: 'string' }),
	pageStatusCode: integer("page_status_code"),
	summary: text(),
	screenshot: text(),
	actions: jsonb(),
	changeTracking: jsonb("change_tracking"),
	rawResponse: jsonb("raw_response"),
	warning: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	domain: text(),
	normalizedUrl: text("normalized_url").notNull(),
}, (table) => [
	index("idx_scraped_url_firecrawl_normalized_url").using("btree", table.normalizedUrl.asc().nullsLast().op("text_ops")),
	index().using("gin", table.actions.asc().nullsLast().op("jsonb_ops")),
	index("scraped_url_firecrawl_content_search_idx").using("gin", sql`to_tsvector('english'::regconfig, COALESCE(content, ''::text))`),
	index().using("btree", table.domain.asc().nullsLast().op("text_ops")),
	index("scraped_url_firecrawl_markdown_search_idx").using("gin", sql`to_tsvector('english'::regconfig, COALESCE(markdown, ''::text))`),
	uniqueIndex("scraped_url_firecrawl_normalized_url_key").using("btree", table.normalizedUrl.asc().nullsLast().op("text_ops")),
	index().using("btree", table.pageStatusCode.asc().nullsLast().op("int4_ops")),
	index().using("gin", table.rawResponse.asc().nullsLast().op("jsonb_ops")),
	index().using("btree", table.scrapeId.asc().nullsLast().op("text_ops")),
	index().using("btree", table.scrapedAt.asc().nullsLast().op("timestamptz_ops")),
	index().using("btree", table.sourceUrl.asc().nullsLast().op("text_ops")),
	index().using("btree", table.success.asc().nullsLast().op("bool_ops")),
	index().using("btree", table.url.asc().nullsLast().op("text_ops")),
]);

export const individualsLinkedinPosts = pgTable("individuals_linkedin_posts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	individualId: uuid("individual_id"),
	rawData: jsonb("raw_data").notNull(),
	postType: text("post_type").notNull(),
	linkedinPostId: text("linkedin_post_id").notNull(),
	linkedinUrl: text("linkedin_url").notNull(),
	content: text(),
	contentAttributes: jsonb("content_attributes"),
	author: jsonb(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	postedAtData: jsonb("posted_at_data"),
	postImages: jsonb("post_images"),
	hasImages: boolean("has_images").default(false),
	repostId: text("repost_id"),
	repostData: jsonb("repost_data"),
	isRepost: boolean("is_repost").default(false),
	socialContent: jsonb("social_content"),
	engagement: jsonb(),
	likesCount: integer("likes_count").default(0),
	commentsCount: integer("comments_count").default(0),
	sharesCount: integer("shares_count").default(0),
	impressionsCount: integer("impressions_count").default(0),
	reactions: jsonb(),
	comments: jsonb(),
	header: jsonb(),
	article: jsonb(),
	articleLink: text("article_link"),
	articleTitle: text("article_title"),
	hasArticle: boolean("has_article").default(false),
	input: jsonb(),
	query: jsonb(),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	articleImageUrl: text("article_image_url"),
	articleDescription: text("article_description"),
}, (table) => [
	index().using("btree", table.authorLinkedinUrl.asc().nullsLast().op("text_ops")),
	index().using("gin", table.contentAttributes.asc().nullsLast().op("jsonb_ops")),
	index("individuals_linkedin_posts_content_search_idx").using("gin", sql`to_tsvector('english'::regconfig, content)`),
	index().using("gin", table.engagement.asc().nullsLast().op("jsonb_ops")),
	index().using("btree", table.individualId.asc().nullsLast().op("uuid_ops")),
	index().using("btree", table.isRepost.asc().nullsLast().op("bool_ops")),
	index().using("btree", table.linkedinPostId.asc().nullsLast().op("text_ops")),
	index().using("btree", table.postType.asc().nullsLast().op("text_ops")),
	index().using("btree", table.postedAt.asc().nullsLast().op("timestamptz_ops")),
	index().using("gin", table.rawData.asc().nullsLast().op("jsonb_ops")),
	index().using("gin", table.reactions.asc().nullsLast().op("jsonb_ops")),
	index().using("btree", table.repostId.asc().nullsLast().op("text_ops")),
	index().using("btree", table.scrapedAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.individualId],
			foreignColumns: [individuals.id],
			name: "individuals_linkedin_posts_individual_id_fkey"
		}).onDelete("set null"),
	unique("individuals_linkedin_posts_linkedin_post_id_key").on(table.linkedinPostId),
]);

export const organizationIdeas = pgTable("organization_ideas", {
	sourceOrganizationId: integer("source_organization_id").primaryKey().generatedAlwaysAsIdentity({ name: "organization_ideas_source_organization_url_seq", startWith: 1, increment: 1, minValue: 1, maxValue: 2147483647, cache: 1 }),
	externalOrganizationId: text("external_organization_id"),
	organizationContrarianIdeas: json("organization_contrarian_ideas"),
});

export const orgs = pgTable("orgs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	appId: text("app_id").notNull(),
	clerkOrgId: text("clerk_org_id").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	uniqueIndex("idx_orgs_app_clerk_id").using("btree", table.appId.asc().nullsLast().op("text_ops"), table.clerkOrgId.asc().nullsLast().op("text_ops")),
]);

export const intakeForms = pgTable("intake_forms", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	brandId: uuid("brand_id").notNull(),
	liveblocksRoomId: text("liveblocks_room_id"),
	nameAndTitle: text("name_and_title"),
	phoneAndEmail: text("phone_and_email"),
	websiteAndSocials: text("website_and_socials"),
	imagesLink: text("images_link"),
	startDate: date("start_date"),
	bio: text(),
	elevatorPitch: text("elevator_pitch"),
	guestPieces: text("guest_pieces"),
	interviewQuestions: text("interview_questions"),
	quotes: text(),
	talkingPoints: text("talking_points"),
	collateral: text(),
	howStarted: text("how_started"),
	whyStarted: text("why_started"),
	mission: text(),
	story: text(),
	previousJobs: text("previous_jobs"),
	offerings: text(),
	currentPromotion: text("current_promotion"),
	problemSolution: text("problem_solution"),
	futureOfferings: text("future_offerings"),
	location: text(),
	goals: text(),
	helpPeople: text("help_people"),
	categories: text(),
	pressTargeting: text("press_targeting"),
	pressType: text("press_type"),
	specificOutlets: text("specific_outlets"),
	status: text(),
	lastSyncedAt: timestamp("last_synced_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	generatingStartedAt: timestamp("generating_started_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index().using("btree", table.liveblocksRoomId.asc().nullsLast().op("text_ops")).where(sql`(liveblocks_room_id IS NOT NULL)`),
	index("intake_forms_organization_id_index").using("btree", table.brandId.asc().nullsLast().op("uuid_ops")),
	index().using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status IS NOT NULL)`),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "intake_forms_organization_id_fkey"
		}).onDelete("cascade"),
	unique("unique_org_intake").on(table.brandId),
	check("intake_forms_status_check", sql`(status IS NULL) OR (status = 'generating'::text)`),
]);

export const brandThesis = pgTable("brand_thesis", {
	id: serial().primaryKey().notNull(),
	brandId: uuid("brand_id").notNull(),
	thesisHtml: text("thesis_html").notNull(),
	contrarianLevel: integer("contrarian_level").notNull(),
	status: organizationIndividualThesisStatus().default('pending').notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	thesisSupportingEvidenceHtml: text("thesis_supporting_evidence_html"),
	generatingStartedAt: timestamp("generating_started_at", { withTimezone: true, mode: 'string' }),
	statusReason: text("status_reason"),
	statusChangedByType: text("status_changed_by_type"),
	statusChangedByUserId: uuid("status_changed_by_user_id"),
	statusChangedAt: timestamp("status_changed_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("organizations_aied_thesis_generating_started_at_index").using("btree", table.generatingStartedAt.asc().nullsLast().op("timestamptz_ops")),
	index("organizations_individuals_aied_thesis_contrarian_level_index").using("btree", table.contrarianLevel.asc().nullsLast().op("int4_ops")),
	index("organizations_individuals_aied_thesis_organization_id_index").using("btree", table.brandId.asc().nullsLast().op("uuid_ops")),
	index("organizations_individuals_aied_thesis_status_index").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "organizations_individuals_aied_thesis_organization_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.statusChangedByUserId],
			foreignColumns: [users.id],
			name: "organizations_aied_thesis_status_changed_by_user_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "organizations_aied_thesis_organization_id_fkey"
		}).onDelete("cascade"),
	unique("unique_org_level_thesis").on(table.brandId, table.thesisHtml, table.contrarianLevel),
	check("check_status_changed_by_type", sql`(status_changed_by_type = ANY (ARRAY['ai'::text, 'user'::text])) OR (status_changed_by_type IS NULL)`),
]);

export const drizzleMigrations = pgTable("__drizzle_migrations", {
	id: serial().primaryKey().notNull(),
	hash: text().notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	createdAt: bigint("created_at", { mode: "number" }),
});

export const webPages = pgTable("web_pages", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	url: text().notNull(),
	pageCategory: webPageCategoryEnum("page_category"),
	shouldScrape: boolean("should_scrape").default(true),
	domain: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	normalizedUrl: text("normalized_url").notNull(),
}, (table) => [
	index("idx_web_pages_domain").using("btree", table.domain.asc().nullsLast().op("text_ops")),
	index("idx_web_pages_should_scrape").using("btree", table.shouldScrape.asc().nullsLast().op("bool_ops")).where(sql`(should_scrape = true)`),
	index("idx_web_pages_url").using("btree", table.url.asc().nullsLast().op("text_ops")),
	uniqueIndex("web_pages_normalized_url_key").using("btree", table.normalizedUrl.asc().nullsLast().op("text_ops")),
]);

export const brandRelations = pgTable("brand_relations", {
	sourceBrandId: uuid("source_brand_id").notNull(),
	targetBrandId: uuid("target_brand_id").notNull(),
	relationType: organizationRelationType("relation_type").default('other').notNull(),
	relationConfidenceLevel: text("relation_confidence_level"),
	relationConfidenceRationale: text("relation_confidence_rationale"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	status: organizationRelationStatus().default('active').notNull(),
}, (table) => [
	index("organization_relations_status_index").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.sourceBrandId],
			foreignColumns: [brands.id],
			name: "organization_relations_source_organization_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.targetBrandId],
			foreignColumns: [brands.id],
			name: "organization_relations_target_organization_id_fkey"
		}).onDelete("cascade"),
	primaryKey({ columns: [table.sourceBrandId, table.targetBrandId], name: "organization_relations_pkey"}),
]);

export const brandIndividuals = pgTable("brand_individuals", {
	brandId: uuid("brand_id").notNull(),
	individualId: uuid("individual_id").notNull(),
	organizationRole: text("organization_role").notNull(),
	joinedOrganizationAt: timestamp("joined_organization_at", { withTimezone: true, mode: 'string' }),
	belongingConfidenceRationale: text("belonging_confidence_rationale").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`).notNull(),
	status: organizationIndividualStatus().default('active').notNull(),
	belongingConfidenceLevel: belongingConfidenceLevelEnum("belonging_confidence_level"),
}, (table) => [
	index("organization_individuals_individual_id_index").using("btree", table.individualId.asc().nullsLast().op("uuid_ops")),
	index("organization_individuals_organization_id_index").using("btree", table.brandId.asc().nullsLast().op("uuid_ops")),
	index("organization_individuals_status_index").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.individualId],
			foreignColumns: [individuals.id],
			name: "organization_individuals_individual_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.brandId],
			foreignColumns: [brands.id],
			name: "organization_individuals_organization_id_fkey"
		}).onDelete("cascade"),
	primaryKey({ columns: [table.brandId, table.individualId], name: "organization_individuals_pkey"}),
]);
export const vIndividualsLinkedinPosts = pgView("v_individuals_linkedin_posts", {	externalOrganizationId: text("external_organization_id"),
	postId: uuid("post_id"),
	individualId: uuid("individual_id"),
	individualName: text("individual_name"),
	linkedinPostId: text("linkedin_post_id"),
	linkedinUrl: text("linkedin_url"),
	postType: text("post_type"),
	content: text(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	articleImageUrl: text("article_image_url"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	likesCount: integer("likes_count"),
	commentsCount: integer("comments_count"),
	sharesCount: integer("shares_count"),
	impressionsCount: integer("impressions_count"),
	hasImages: boolean("has_images"),
	postImages: jsonb("post_images"),
	isRepost: boolean("is_repost"),
	repostId: text("repost_id"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT o.external_organization_id, lp.id AS post_id, i.id AS individual_id, TRIM(BOTH FROM concat(i.first_name, ' ', i.last_name)) AS individual_name, lp.linkedin_post_id, lp.linkedin_url, lp.post_type, lp.content, lp.author_name, lp.author_linkedin_url, lp.author_avatar_url, lp.author_info, lp.article_image_url, lp.posted_at, lp.likes_count, lp.comments_count, lp.shares_count, lp.impressions_count, lp.has_images, lp.post_images, lp.is_repost, lp.repost_id, lp.scraped_at, lp.created_at, lp.updated_at FROM brands o JOIN brand_individuals oi ON o.id = oi.brand_id JOIN individuals i ON oi.individual_id = i.id JOIN individuals_linkedin_posts lp ON i.id = lp.individual_id WHERE lp.has_article = false ORDER BY o.external_organization_id, lp.posted_at DESC NULLS LAST, lp.created_at DESC`);

export const vOrganizationScrapedPages = pgView("v_organization_scraped_pages", {	externalOrganizationId: text("external_organization_id"),
	id: uuid(),
	url: text(),
	domain: text(),
	title: text(),
	description: text(),
	content: text(),
	markdown: text(),
	hasContent: boolean("has_content"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	pageCategory: webPageCategoryEnum("page_category"),
}).as(sql`SELECT o.external_organization_id, s.id, s.url, s.domain, s.title, s.description, s.content, s.markdown, CASE WHEN s.content IS NOT NULL AND s.content <> ''::text THEN true ELSE false END AS has_content, s.scraped_at, s.created_at, wp.page_category FROM brands o JOIN web_pages wp ON o.domain = wp.domain JOIN scraped_url_firecrawl s ON wp.normalized_url = s.normalized_url WHERE o.domain IS NOT NULL AND wp.domain IS NOT NULL AND s.raw_response IS NOT NULL ORDER BY o.external_organization_id, s.scraped_at DESC NULLS LAST, s.created_at DESC`);

export const vIndividualsPersonalContent = pgView("v_individuals_personal_content", {	externalOrganizationId: text("external_organization_id"),
	scrapedId: uuid("scraped_id"),
	individualId: uuid("individual_id"),
	individualName: text("individual_name"),
	url: text(),
	domain: text(),
	title: text(),
	description: text(),
	content: text(),
	markdown: text(),
	hasContent: boolean("has_content"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT o.external_organization_id, s.id AS scraped_id, i.id AS individual_id, TRIM(BOTH FROM concat(i.first_name, ' ', i.last_name)) AS individual_name, s.url, s.domain, s.title, s.description, s.content, s.markdown, CASE WHEN s.content IS NOT NULL AND s.content <> ''::text THEN true ELSE false END AS has_content, s.scraped_at, s.created_at FROM brands o JOIN brand_individuals oi ON o.id = oi.brand_id JOIN individuals i ON oi.individual_id = i.id JOIN scraped_url_firecrawl s ON CASE WHEN i.personal_website_url IS NOT NULL THEN regexp_replace(regexp_replace(i.personal_website_url, '^https?://(www\.)?'::text, ''::text), '/.*$'::text, ''::text) ELSE NULL::text END = s.domain WHERE i.personal_website_url IS NOT NULL AND s.raw_response IS NOT NULL ORDER BY o.external_organization_id, s.scraped_at DESC NULLS LAST, s.created_at DESC`);

export const vOrganizationLinkedinPosts = pgView("v_organization_linkedin_posts", {	externalOrganizationId: text("external_organization_id"),
	id: uuid(),
	linkedinPostId: text("linkedin_post_id"),
	linkedinUrl: text("linkedin_url"),
	postType: text("post_type"),
	content: text(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	authorUniversalName: text("author_universal_name"),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	articleImageUrl: text("article_image_url"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	likesCount: integer("likes_count"),
	commentsCount: integer("comments_count"),
	sharesCount: integer("shares_count"),
	impressionsCount: integer("impressions_count"),
	hasImages: boolean("has_images"),
	postImages: jsonb("post_images"),
	isRepost: boolean("is_repost"),
	repostId: text("repost_id"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT o.external_organization_id, lp.id, lp.linkedin_post_id, lp.linkedin_url, lp.post_type, lp.content, lp.author_name, lp.author_linkedin_url, lp.author_universal_name, lp.author_avatar_url, lp.author_info, lp.article_image_url, lp.posted_at, lp.likes_count, lp.comments_count, lp.shares_count, lp.impressions_count, lp.has_images, lp.post_images, lp.is_repost, lp.repost_id, lp.scraped_at, lp.created_at, lp.updated_at FROM brands o JOIN brand_linkedin_posts lp ON o.id = lp.brand_id WHERE lp.has_article = false ORDER BY o.external_organization_id, lp.posted_at DESC NULLS LAST, lp.created_at DESC`);

export const vIndividualsLinkedinArticles = pgView("v_individuals_linkedin_articles", {	externalOrganizationId: text("external_organization_id"),
	postId: uuid("post_id"),
	individualId: uuid("individual_id"),
	individualName: text("individual_name"),
	linkedinPostId: text("linkedin_post_id"),
	linkedinUrl: text("linkedin_url"),
	postType: text("post_type"),
	content: text(),
	articleTitle: text("article_title"),
	articleLink: text("article_link"),
	articleImageUrl: text("article_image_url"),
	articleDescription: text("article_description"),
	article: jsonb(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	likesCount: integer("likes_count"),
	commentsCount: integer("comments_count"),
	sharesCount: integer("shares_count"),
	impressionsCount: integer("impressions_count"),
	hasImages: boolean("has_images"),
	postImages: jsonb("post_images"),
	isRepost: boolean("is_repost"),
	repostId: text("repost_id"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	scrapedId: uuid("scraped_id"),
	scrapedSourceUrl: text("scraped_source_url"),
	scrapedUrl: text("scraped_url"),
	scrapedDomain: text("scraped_domain"),
	scrapedTitle: text("scraped_title"),
	scrapedDescription: text("scraped_description"),
	scrapedContent: text("scraped_content"),
	scrapedMarkdown: text("scraped_markdown"),
	scrapedHtml: text("scraped_html"),
	scrapedRawHtml: text("scraped_raw_html"),
	scrapedLinks: text("scraped_links"),
	scrapedLanguage: text("scraped_language"),
	scrapedOgTitle: text("scraped_og_title"),
	scrapedOgDescription: text("scraped_og_description"),
	scrapedOgImage: text("scraped_og_image"),
	scrapedPageScrapedAt: timestamp("scraped_page_scraped_at", { withTimezone: true, mode: 'string' }),
	scrapedPageCreatedAt: timestamp("scraped_page_created_at", { withTimezone: true, mode: 'string' }),
	hasScrapedContent: boolean("has_scraped_content"),
}).as(sql`SELECT o.external_organization_id, lp.id AS post_id, i.id AS individual_id, TRIM(BOTH FROM concat(i.first_name, ' ', i.last_name)) AS individual_name, lp.linkedin_post_id, lp.linkedin_url, lp.post_type, lp.content, lp.article_title, lp.article_link, lp.article_image_url, lp.article_description, lp.article, lp.author_name, lp.author_linkedin_url, lp.author_avatar_url, lp.author_info, lp.posted_at, lp.likes_count, lp.comments_count, lp.shares_count, lp.impressions_count, lp.has_images, lp.post_images, lp.is_repost, lp.repost_id, lp.scraped_at, lp.created_at, lp.updated_at, scraped.id AS scraped_id, scraped.source_url AS scraped_source_url, scraped.url AS scraped_url, scraped.domain AS scraped_domain, scraped.title AS scraped_title, scraped.description AS scraped_description, scraped.content AS scraped_content, scraped.markdown AS scraped_markdown, scraped.html AS scraped_html, scraped.raw_html AS scraped_raw_html, scraped.links AS scraped_links, scraped.language AS scraped_language, scraped.og_title AS scraped_og_title, scraped.og_description AS scraped_og_description, scraped.og_image AS scraped_og_image, scraped.scraped_at AS scraped_page_scraped_at, scraped.created_at AS scraped_page_created_at, CASE WHEN scraped.content IS NOT NULL AND scraped.content <> ''::text THEN true ELSE false END AS has_scraped_content FROM brands o JOIN brand_individuals oi ON o.id = oi.brand_id JOIN individuals i ON oi.individual_id = i.id JOIN individuals_linkedin_posts lp ON i.id = lp.individual_id LEFT JOIN scraped_url_firecrawl scraped ON lp.article_link = scraped.source_url WHERE lp.has_article = true ORDER BY o.external_organization_id, lp.posted_at DESC NULLS LAST, lp.created_at DESC`);

export const vOrganizationLinkedinArticles = pgView("v_organization_linkedin_articles", {	externalOrganizationId: text("external_organization_id"),
	id: uuid(),
	linkedinPostId: text("linkedin_post_id"),
	linkedinUrl: text("linkedin_url"),
	postType: text("post_type"),
	content: text(),
	articleTitle: text("article_title"),
	articleLink: text("article_link"),
	articleImageUrl: text("article_image_url"),
	articleDescription: text("article_description"),
	article: jsonb(),
	authorName: text("author_name"),
	authorLinkedinUrl: text("author_linkedin_url"),
	authorUniversalName: text("author_universal_name"),
	authorAvatarUrl: text("author_avatar_url"),
	authorInfo: jsonb("author_info"),
	postedAt: timestamp("posted_at", { withTimezone: true, mode: 'string' }),
	likesCount: integer("likes_count"),
	commentsCount: integer("comments_count"),
	sharesCount: integer("shares_count"),
	impressionsCount: integer("impressions_count"),
	hasImages: boolean("has_images"),
	postImages: jsonb("post_images"),
	isRepost: boolean("is_repost"),
	repostId: text("repost_id"),
	scrapedAt: timestamp("scraped_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	scrapedId: uuid("scraped_id"),
	scrapedSourceUrl: text("scraped_source_url"),
	scrapedUrl: text("scraped_url"),
	scrapedDomain: text("scraped_domain"),
	scrapedTitle: text("scraped_title"),
	scrapedDescription: text("scraped_description"),
	scrapedContent: text("scraped_content"),
	scrapedMarkdown: text("scraped_markdown"),
	scrapedHtml: text("scraped_html"),
	scrapedRawHtml: text("scraped_raw_html"),
	scrapedLinks: text("scraped_links"),
	scrapedLanguage: text("scraped_language"),
	scrapedOgTitle: text("scraped_og_title"),
	scrapedOgDescription: text("scraped_og_description"),
	scrapedOgImage: text("scraped_og_image"),
	scrapedPageScrapedAt: timestamp("scraped_page_scraped_at", { withTimezone: true, mode: 'string' }),
	scrapedPageCreatedAt: timestamp("scraped_page_created_at", { withTimezone: true, mode: 'string' }),
	hasScrapedContent: boolean("has_scraped_content"),
}).as(sql`SELECT o.external_organization_id, lp.id, lp.linkedin_post_id, lp.linkedin_url, lp.post_type, lp.content, lp.article_title, lp.article_link, lp.article_image_url, lp.article_description, lp.article, lp.author_name, lp.author_linkedin_url, lp.author_universal_name, lp.author_avatar_url, lp.author_info, lp.posted_at, lp.likes_count, lp.comments_count, lp.shares_count, lp.impressions_count, lp.has_images, lp.post_images, lp.is_repost, lp.repost_id, lp.scraped_at, lp.created_at, lp.updated_at, scraped.id AS scraped_id, scraped.source_url AS scraped_source_url, scraped.url AS scraped_url, scraped.domain AS scraped_domain, scraped.title AS scraped_title, scraped.description AS scraped_description, scraped.content AS scraped_content, scraped.markdown AS scraped_markdown, scraped.html AS scraped_html, scraped.raw_html AS scraped_raw_html, scraped.links AS scraped_links, scraped.language AS scraped_language, scraped.og_title AS scraped_og_title, scraped.og_description AS scraped_og_description, scraped.og_image AS scraped_og_image, scraped.scraped_at AS scraped_page_scraped_at, scraped.created_at AS scraped_page_created_at, CASE WHEN scraped.content IS NOT NULL AND scraped.content <> ''::text THEN true ELSE false END AS has_scraped_content FROM brands o JOIN brand_linkedin_posts lp ON o.id = lp.brand_id LEFT JOIN scraped_url_firecrawl scraped ON lp.article_link = scraped.source_url WHERE lp.has_article = true ORDER BY o.external_organization_id, lp.posted_at DESC NULLS LAST, lp.created_at DESC`);

export const vOrganizationIndividuals = pgView("v_organization_individuals", {	externalOrganizationId: text("external_organization_id"),
	individualId: uuid("individual_id"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	fullName: text("full_name"),
	linkedinUrl: text("linkedin_url"),
	personalWebsiteUrl: text("personal_website_url"),
	personalDomain: text("personal_domain"),
	pdlId: text("pdl_id"),
	pdlFullName: text("pdl_full_name"),
	pdlLocationName: text("pdl_location_name"),
	pdlJobTitle: text("pdl_job_title"),
	pdlJobCompanyName: text("pdl_job_company_name"),
	pdlJobCompanyIndustry: text("pdl_job_company_industry"),
	pdlLinkedinUrl: text("pdl_linkedin_url"),
	pdlJobCompanyWebsite: text("pdl_job_company_website"),
	pdlTwitterUrl: text("pdl_twitter_url"),
	pdlFacebookUrl: text("pdl_facebook_url"),
	pdlGithubUrl: text("pdl_github_url"),
	linkedinAuthorAvatarUrl: text("linkedin_author_avatar_url"),
	linkedinAuthorInfo: jsonb("linkedin_author_info"),
	relationCreatedAt: timestamp("relation_created_at", { withTimezone: true, mode: 'string' }),
	individualCreatedAt: timestamp("individual_created_at", { withTimezone: true, mode: 'string' }),
	relationshipStatus: organizationIndividualStatus("relationship_status"),
	organizationRole: text("organization_role"),
	joinedOrganizationAt: timestamp("joined_organization_at", { withTimezone: true, mode: 'string' }),
	belongingConfidenceLevel: belongingConfidenceLevelEnum("belonging_confidence_level"),
	belongingConfidenceRationale: text("belonging_confidence_rationale"),
}).as(sql`SELECT o.external_organization_id, i.id AS individual_id, i.first_name, i.last_name, TRIM(BOTH FROM concat(i.first_name, ' ', i.last_name)) AS full_name, i.linkedin_url, i.personal_website_url, CASE WHEN i.personal_website_url IS NOT NULL THEN regexp_replace(regexp_replace(i.personal_website_url, '^https?://(www\.)?'::text, ''::text), '/.*$'::text, ''::text) ELSE NULL::text END AS personal_domain, pdl.pdl_id, pdl.full_name AS pdl_full_name, pdl.location_name AS pdl_location_name, pdl.job_title AS pdl_job_title, pdl.job_company_name AS pdl_job_company_name, pdl.job_company_industry AS pdl_job_company_industry, pdl.linkedin_url AS pdl_linkedin_url, pdl.job_company_website AS pdl_job_company_website, pdl.twitter_url AS pdl_twitter_url, pdl.facebook_url AS pdl_facebook_url, pdl.github_url AS pdl_github_url, latest_post.author_avatar_url AS linkedin_author_avatar_url, latest_post.author_info AS linkedin_author_info, oi.created_at AS relation_created_at, i.created_at AS individual_created_at, oi.status AS relationship_status, oi.organization_role, oi.joined_organization_at, oi.belonging_confidence_level, oi.belonging_confidence_rationale FROM brands o JOIN brand_individuals oi ON o.id = oi.brand_id JOIN individuals i ON oi.individual_id = i.id LEFT JOIN individuals_pdl_enrichment pdl ON i.id = pdl.individual_id LEFT JOIN LATERAL ( SELECT lp.author_avatar_url, lp.author_info FROM individuals_linkedin_posts lp WHERE lp.individual_id = i.id ORDER BY lp.scraped_at DESC NULLS LAST, lp.created_at DESC LIMIT 1) latest_post ON true ORDER BY o.external_organization_id, oi.created_at DESC, i.created_at DESC`);

export const vTargetOrganizations = pgView("v_target_organizations", {	sourceExternalOrganizationId: text("source_external_organization_id"),
	targetOrgId: uuid("target_org_id"),
	targetOrgExternalId: text("target_org_external_id"),
	targetOrgName: text("target_org_name"),
	targetOrgUrl: text("target_org_url"),
	targetOrgLinkedinUrl: text("target_org_linkedin_url"),
	targetOrgDomain: text("target_org_domain"),
	relationType: organizationRelationType("relation_type"),
	relationConfidenceLevel: text("relation_confidence_level"),
	relationConfidenceRationale: text("relation_confidence_rationale"),
	relationStatus: organizationRelationStatus("relation_status"),
	relationCreatedAt: timestamp("relation_created_at", { withTimezone: true, mode: 'string' }),
	relationUpdatedAt: timestamp("relation_updated_at", { withTimezone: true, mode: 'string' }),
	targetOrgLocation: text("target_org_location"),
	targetOrgBio: text("target_org_bio"),
	targetOrgElevatorPitch: text("target_org_elevator_pitch"),
	targetOrgMission: text("target_org_mission"),
	targetOrgStory: text("target_org_story"),
	targetOrgOfferings: text("target_org_offerings"),
	targetOrgProblemSolution: text("target_org_problem_solution"),
	targetOrgGoals: text("target_org_goals"),
	targetOrgCategories: text("target_org_categories"),
	targetOrgFoundedDate: date("target_org_founded_date"),
	targetOrgContactName: text("target_org_contact_name"),
	targetOrgContactEmail: text("target_org_contact_email"),
	targetOrgContactPhone: text("target_org_contact_phone"),
	targetOrgSocialMedia: jsonb("target_org_social_media"),
}).as(sql`SELECT source_org.external_organization_id AS source_external_organization_id, target_org.id AS target_org_id, target_org.external_organization_id AS target_org_external_id, target_org.name AS target_org_name, target_org.url AS target_org_url, target_org.organization_linkedin_url AS target_org_linkedin_url, target_org.domain AS target_org_domain, rel.relation_type, rel.relation_confidence_level, rel.relation_confidence_rationale, rel.status AS relation_status, rel.created_at AS relation_created_at, rel.updated_at AS relation_updated_at, target_org.location AS target_org_location, target_org.bio AS target_org_bio, target_org.elevator_pitch AS target_org_elevator_pitch, target_org.mission AS target_org_mission, target_org.story AS target_org_story, target_org.offerings AS target_org_offerings, target_org.problem_solution AS target_org_problem_solution, target_org.goals AS target_org_goals, target_org.categories AS target_org_categories, target_org.founded_date AS target_org_founded_date, target_org.contact_name AS target_org_contact_name, target_org.contact_email AS target_org_contact_email, target_org.contact_phone AS target_org_contact_phone, target_org.social_media AS target_org_social_media FROM brands source_org JOIN brand_relations rel ON source_org.id = rel.source_brand_id JOIN brands target_org ON rel.target_brand_id = target_org.id ORDER BY source_org.external_organization_id, rel.created_at DESC`);

// Deprecated: tasks, tasks_runs, tasks_runs_costs tables removed from schema.
// Run tracking is now handled by runs-service via src/lib/runs-client.ts.
// The physical tables still exist in the database but are no longer used.
